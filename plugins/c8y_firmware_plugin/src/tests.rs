use super::*;
use crate::message::RequestPayload;
use crate::message::ResponsePayload;
use crate::FirmwareManager;
use c8y_api::http_proxy::MockC8YHttpProxy;
use mockall::predicate;
use serde_json::json;
use sha256::digest;
use sha256::try_digest;
use std::sync::Arc;
use tedge_api::OperationStatus;
use tedge_test_utils::fs::TempTedgeDir;

const TEST_TIMEOUT_MS: Duration = Duration::from_millis(5000);

#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
#[serial_test::serial]
async fn test_handle_firmware_update_request_child_device() -> anyhow::Result<()> {
    let child_device_id = "child-device";
    let firmware_name = "fw-name";
    let firmware_version = "fw-version";

    // Create required directories
    let tmp_dir = TempTedgeDir::new();
    tmp_dir.dir("cache");
    tmp_dir.dir("file-transfer");
    tmp_dir.dir("firmware");

    let broker = mqtt_tests::test_mqtt_broker();
    let mut c8y_http_client = MockC8YHttpProxy::new();

    c8y_http_client
        .expect_download_file()
        .with(
            predicate::always(),
            predicate::always(),
            predicate::always(),
        )
        .returning(|_, file_name, tmp_dir_path| {
            let downloaded_path = tmp_dir_path.join(file_name);
            std::fs::File::create(&downloaded_path)?;
            Ok(downloaded_path)
        });

    let mut firmware_manager = FirmwareManager::new(
        "tedge_device_id".to_string(),
        broker.port,
        Arc::new(Mutex::new(c8y_http_client)),
        mockito::server_address().to_string(),
        tmp_dir.to_path_buf(),
        tmp_dir.to_path_buf(),
        Duration::from_secs(3600),
    )
    .await?;

    // Run the plugin's runtime logic in an async task
    tokio::spawn(async move {
        let _ = firmware_manager.run().await;
    });

    // Mock download endpoint for the plugin to download config file update from the cloud
    let cloud_url_path = "/some/cloud/url";
    let mock_http_server_host = mockito::server_url();
    let cloud_firmware_url = format!("{mock_http_server_host}{cloud_url_path}");
    let file_cache_key = digest(cloud_firmware_url.clone());
    let firmware_file_path_in_cache_dir = tmp_dir
        .path()
        .join("firmware")
        .join("cache")
        .join(file_cache_key.clone());

    let mut tedge_command_messages = broker
        .messages_published_on(&format!(
            "tedge/{child_device_id}/commands/req/firmware_update"
        ))
        .await;

    // Send a c8y_Firmware operation to the plugin
    broker
        .publish(
            "c8y/s/ds",
            format!(
                "515,{child_device_id},{firmware_name},{firmware_version},{cloud_firmware_url}"
            )
            .as_str(),
        )
        .await?;

    // Since sha256 is generated by the downloaded file, can create RequestPayload after publishing 515.
    // TODO! How to ignore the operation ID from the test result? It's randomly generated...
    let file_sha256 = try_digest(firmware_file_path_in_cache_dir.as_path())?;
    let expected_request_payload = RequestPayload {
        operation_id: "not-checked".to_string(),
        attempt: 1,
        name: firmware_name.to_string(),
        version: firmware_version.to_string(),
        sha256: file_sha256,
        file_transfer_url: format!("{mock_http_server_host}/tedge/file-transfer/{child_device_id}/firmware_update/{file_cache_key}").to_string()
    };
    let expected_request = serde_json::to_string(&expected_request_payload)?;

    // Assert the mapping from c8y_Firmware operation to tedge command
    mqtt_tests::assert_received_all_expected(
        &mut tedge_command_messages,
        TEST_TIMEOUT_MS,
        &[expected_request],
    )
    .await;

    Ok(())
}

// FIXME: Timer is not called before and doesn't have operation ID, hence, this test doesn't work.
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
#[serial_test::serial]
async fn test_handle_firmware_update_response_child_device() -> anyhow::Result<()> {
    let operation_id = "op-id";
    let child_device_id = "child-device";
    let firmware_name = "fw-name";
    let firmware_version = "fw-version";
    let firmware_url = "server-url";

    // Create required directories
    let tmp_dir = TempTedgeDir::new();
    let content = json!({
      "operation_id": operation_id,
      "child_id": child_device_id,
      "name": firmware_name,
      "version": firmware_version,
      "server_url": firmware_url,
      "file_transfer_url": "file-transfer-url",
      "sha256": "abcd1234",
      "attempt": 1
    })
    .to_string();
    tmp_dir
        .dir("firmware")
        .file(operation_id)
        .with_raw_content(&content);

    let broker = mqtt_tests::test_mqtt_broker();
    let c8y_http_client = MockC8YHttpProxy::new();

    let mut firmware_manager = FirmwareManager::new(
        "tedge_device_id".to_string(),
        broker.port,
        Arc::new(Mutex::new(c8y_http_client)),
        mockito::server_address().to_string(),
        tmp_dir.to_path_buf(),
        tmp_dir.to_path_buf(),
        Duration::from_secs(3600),
    )
    .await?;

    // Run the plugin's runtime logic in an async task
    tokio::spawn(async move {
        let _ = firmware_manager.run().await;
    });

    // Response from child device
    broker
        .publish(
            &format!("tedge/{child_device_id}/commands/res/firmware_update"),
            &serde_json::to_string(&ResponsePayload {
                operation_id: operation_id.to_string(),
                status: OperationStatus::Successful,
                reason: None,
            })
            .unwrap(),
        )
        .await?;

    let mut smartrest_messages = broker
        .messages_published_on(format!("c8y/s/us/{child_device_id}").as_str())
        .await;

    let set_firmware_sm = "115,{firmware_name},{firmware_version},{firmware_url}";
    // Assert the c8y_Firmware operation status mapping to EXECUTING(501), SUCCESSFUL(503), and Set Firmware(115)
    mqtt_tests::assert_received_all_expected(
        &mut smartrest_messages,
        TEST_TIMEOUT_MS,
        &["501,c8y_Firmware", "503,c8y_Firmware", set_firmware_sm],
    )
    .await;

    Ok(())
}
